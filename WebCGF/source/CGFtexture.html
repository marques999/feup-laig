<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='CGFtexture'>/**
</span>* @class CGFtexture
*
* Handles texture loading, binding and unbinding. It can be used implicitly in CGFappearance, 
* but it also can be used to load textures independently and dynamically add them to appearances
*/

<span id='CGFtexture-method-CGFtexture'>/**
</span> * @method CGFtexture
 * @constructor
 * @param {CGFscene} scene 
 * @param {String} url 
 */
function CGFtexture(scene, url) {
    this.scene=scene;
    this.texID = -1;
    this.gl = scene.gl;

    this.image = new Image();
    this.image.crossOrigin = &quot;anonymous&quot;;
    var self = this;
    this.image.onload = function () {
        console.log(&quot;Texture loaded: &quot; + self.image.src);

        self.texID = self.gl.createTexture();
        self.gl.bindTexture(self.gl.TEXTURE_2D, self.texID);
        self.gl.texImage2D(self.gl.TEXTURE_2D, 0, self.gl.RGBA, self.gl.RGBA, self.gl.UNSIGNED_BYTE, self.image);
        self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_MAG_FILTER, self.gl.LINEAR);
        if (isPowerOfTwo(self.image.width) &amp;&amp; isPowerOfTwo(self.image.height))
        {
            self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_MIN_FILTER, self.gl.LINEAR);
            // temporarily disabled mipmapping, as would generate artifacts in clamp to edge textures
            //self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_MIN_FILTER, self.gl.LINEAR_MIPMAP_NEAREST);
            //self.gl.generateMipmap(self.gl.TEXTURE_2D);
        }
        else
        {
            // MIN FILTER set to linear to cope with Non-power-of-two textures
            self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_MIN_FILTER, self.gl.LINEAR);
            self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_WRAP_S, self.gl.CLAMP_TO_EDGE);
            self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_WRAP_T, self.gl.CLAMP_TO_EDGE);
        } 

    };
    this.image.src = url;
}

function isPowerOfTwo(x) {
    return (x &amp; (x - 1)) == 0;
}

<span id='CGFtexture-method-bind'>/** @method bind
</span> * Binds this texture, becoming the active texture. If another texture was bound, it will be unbound implicitly.
 * @returns {boolean} true if texture was successfully bound, false otherwise (may happen if texture is still being loaded)
*/
CGFtexture.prototype.bind = function () {
    if (this.texID != -1)
    {
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texID);
        this.scene.activeTexture=this;
        return true;
    }
    else
        return false;
};

<span id='CGFtexture-method-unbind'>/**
</span> * @method unbind
 * Unbinds the currently bound texture.
 * It is one way to disable texturing.
 * Not necessary if another texture is bound instead
 */
CGFtexture.prototype.unbind = function () {
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    this.scene.activeTexture=null;
};</pre>
</body>
</html>
