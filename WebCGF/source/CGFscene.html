<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='CGFscene'>/**
</span> * @class CGFscene
 * 
 * Defines a scene, and provides the basis #init, #update and #display methods required to handle a scene. 
 *
 * Typically, there should be a sub-class of this that implements those methods to render the actual scene, calling the methods from this base class.
 * 
 * This class also provides core methods and structures for:
 *
 * - Handling a matrix stack and basic transformations (translation, rotation, scale)
 * - Accessing lights (individually stored as instances of the {@link CGFlight} class)
 * - Controlling the active material properties
 *
 */

 
<span id='CGFscene-method-CGFscene'>/**
</span> * @method CGFscene
 * @constructor
 * A basic constructor
 */
function CGFscene() {
}

<span id='CGFscene-method-init'>/**
</span> * @method init
 * Initialization function that is called by CGFapplication.initScene. It gets the application as parameter, which provides the reference to the WebGL context, among other information.
 * This method handles:
 
 * - the creation of the projection and modelview matrices and the matrix stack, 
 * - the standard shaders for Gouraud shading
 * - the initialization of lights (all disabled by default)
 
 * @param {CGFapplication} application The main application that includes this scene.
 * @returns {boolean} Indicates if initialization was successful
 * @template
 */
CGFscene.prototype.init = function (application) {
    console.log(&quot;Initializing Scene&quot;);
    this.gl = application.gl;
	this.pMatrix = 	mat4.create();

	this.activeMatrix=mat4.create();
	this.matrixStack=new Array();

	this.shader = new CGFshader(
        this.gl,
        '../lib/CGF/shaders/Gouraud/textured/multiple_light-vertex.glsl',
        '../lib/CGF/shaders/Gouraud/textured/fragment.glsl'
    );

	this.shader.bind();

	// set texture unit 0 as the default for shader texture
	this.gl.activeTexture(this.gl.TEXTURE0);
	this.gl.uniform1i(this.shader.uniforms.uSampler, 0);


    //Set textures as disabled by default
    this.enableTextures(false);

    //Store pointer for active texture
    this.activeTexture=null;


	// Initialize lights
	this.lights=new Array();
	var i=0;
	for(var ul in this.shader.uniforms.uLight)
	{
		this.lights[i]=new CGFlight(this,i);
		this.lights[i].disable();
		this.lights[i].update();
		i++;
	};
    
    this.gl.enable(this.gl.DEPTH_TEST);
    this.gl.depthFunc(this.gl.LEQUAL);
    
	this.setGlobalAmbientLight(0.1,0.1,0.1, 1.0);
	
	this.lastUpdate=0;
	this.updatePeriod=0;

    return true;
};

<span id='CGFscene-method-enableTextures'>/**
</span> * @method enableTextures
 *
 * .
 */
CGFscene.prototype.enableTextures = function (useT) {
	this.shader.bind();
	this.texturesEnabled=useT;
	this.gl.uniform1i (this.shader.uniforms.uUseTexture, useT);
};

//------------------------------
// Matrices and Stack

<span id='CGFscene-method-loadIdentity'>/**
</span> * @method loadIdentity
 *
 * Loads (sets) the current transformation matrix with the identity matrix.
 */
CGFscene.prototype.loadIdentity = function ()
{
	mat4.identity(this.activeMatrix);
}; 

<span id='CGFscene-method-pushMatrix'>/**
</span> * @method pushMatrix
 * 
 * Pushes the current transformation matrix to the scene's matrix stack, so that it can be recovered later using #popMatrix
 *
 */
CGFscene.prototype.pushMatrix = function ()
{
	this.matrixStack.push(this.activeMatrix);
	this.activeMatrix=mat4.clone(this.activeMatrix);
} ;

<span id='CGFscene-method-popMatrix'>/**
</span> * @method popMatrix
 * 
 * Pops the last matrix stored with #pushMatrix from the scene's matrix stack, replacing the current transformation matrix
 */
CGFscene.prototype.popMatrix = function ()
{
	this.activeMatrix=this.matrixStack.pop();
};

<span id='CGFscene-method-multMatrix'>/**
</span> * @method multMatrix
 *
 *  Multiplies a matrix with the current scene's transformation matrix, replacing it.
 *
 * @param {mat4} m The matrix to be multiplied
 *
 */
CGFscene.prototype.multMatrix = function (m) 
{
	mat4.multiply(this.activeMatrix, this.activeMatrix, m);
};

<span id='CGFscene-method-getMatrix'>/**
</span> * @method getMatrix
 *
 *  Returns a copy of the current scene's transformation matrix
 *
 *
 */
CGFscene.prototype.getMatrix = function () 
{
	return mat4.clone(this.activeMatrix);
};

<span id='CGFscene-method-setMatrix'>/**
</span> * @method setMatrix
 *
 *  Sets the current scene's transformation matrix
 *
 * @param {mat4} m The matrix to use as a transformation matrix
 *
 */
CGFscene.prototype.setMatrix = function (m) 
{
	this.activeMatrix = mat4.clone(m);
};

//-------------------------------
// Transformations

<span id='CGFscene-method-translate'>/**
</span> * @method translate
 *
 * Creates a translation matrix and multiplies it with the current transformation matrix
 *
 * @param {Number} x  
 * @param {Number} y 
 * @param {Number} z 
 */
CGFscene.prototype.translate = function (x, y, z) 
{
	mat4.translate(this.activeMatrix, this.activeMatrix, [x, y, z]);
};

<span id='CGFscene-method-rotate'>/**
</span> * @method 
 *
 * Creates a rotation matrix and multiplies it with the current transformation matrix
 *
 * @param {Number} a Angle in radians 
 * @param {Number} x component of the axis
 * @param {Number} y component of the axis
 * @param {Number} z component of the axis
 */
CGFscene.prototype.rotate = function (a, x, y, z) 
{
	mat4.rotate(this.activeMatrix, this.activeMatrix, a, [x, y, z]);
};

<span id='CGFscene-method-scale'>/**
</span> * @method scale
 *
 * Creates a scaling matrix and multiplies it with the current transformation matrix
 *
 * @param {Number} x The scale factor in the x direction  
 * @param {Number} y The scale factor in the y direction 
 * @param {Number} z The scale factor in the z direction
 */
CGFscene.prototype.scale = function (x, y, z) 
{
	mat4.scale(this.activeMatrix, this.activeMatrix, [x, y, z]);
};


//-------------------------------
// Materials

CGFscene.prototype.setAmbient = function (r, g, b, a) { this.gl.uniform4fv(this.shader.uniforms.uFrontMaterial.ambient, [r, g, b, a]); }; 
CGFscene.prototype.setDiffuse = function (r, g, b, a) { this.gl.uniform4fv(this.shader.uniforms.uFrontMaterial.diffuse, [r, g, b, a]); }; 
CGFscene.prototype.setSpecular = function (r, g, b, a) { this.gl.uniform4fv(this.shader.uniforms.uFrontMaterial.specular, [r, g, b, a]); }; 
CGFscene.prototype.setShininess = function (s) { this.gl.uniform1f(this.shader.uniforms.uFrontMaterial.shininess, s); }; 
CGFscene.prototype.setEmission = function (r, g, b, a) { this.gl.uniform4fv(this.shader.uniforms.uFrontMaterial.emission, [r, g, b, a]); };

<span id='CGFscene-method-updateProjectionMatrix'>/**
</span> * @method updateProjectionMatrix
 *
 * Recomputes the projection matrix, taking into account the canvas dimensions and the active camera's parameters
 * Can be called explicitly, or implicitly when e.g. the window is resized.
 * 
 */

CGFscene.prototype.updateProjectionMatrix = function ()
{
	this.pMatrix = this.camera.getProjectionMatrix(this.gl.canvas.width, this.gl.canvas.height);
	
	this.gl.uniformMatrix4fv(this.shader.uniforms.uPMatrix, false, this.pMatrix);
};

<span id='CGFscene-method-applyViewMatrix'>/**
</span> * @method applyViewMatrix
 *
 * Updates the current transformation matrix, adding the transformation corresponding to the active camera's position and orientation.
 * Should be called explicitly in the initial part of #display, after resetting the matrix using #loadIdentity.
 * 
 */
CGFscene.prototype.applyViewMatrix = function ()
{
    mat4.mul(this.activeMatrix, this.activeMatrix, this.camera.getViewMatrix());
	
};

<span id='CGFscene-method-update'>/**
</span> * @method update
 *
 * Callback used when it is necessary to update some internal state independent of the rendering (#display) of the scene.
 * Should be reimplemented by descendants.
 *
 * @param {Number} currTime the current time in milliseconds
 *
 * @template
 */
CGFscene.prototype.update = function (currTime) {

}

<span id='CGFscene-method-setUpdatePeriod'>/**
</span> * @method setUpdatePeriod
 * 
 * Setter for updatePeriod.
 * If updatePeriod &gt; 0, #update will be called repeatedly with a delay of aproximately millis milliseconds between each call.
 *
 * @param {Number} millis the desired delay between update calls.
 */
CGFscene.prototype.setUpdatePeriod = function (millis) {
	
	this.updatePeriod=millis;
}


<span id='CGFscene-method-checkUpdate'>/**
</span> * @method checkUpdate
 * 
 * Method used by CGFapplication to call update.
 * If updatePeriod&gt;0 and the last update was more than updatePeriod milliseconds ago, then #update is called with the current time.
 *
 */
CGFscene.prototype.checkUpdate = function(){
	if (this.updatePeriod&gt;0)
	{
		var currTime=Date.now();
		if (currTime-this.lastUpdate&gt;=this.updatePeriod)
		{
			this.update(currTime);
			this.lastUpdate=currTime;
		}
	}
}


<span id='CGFscene-method-display'>/**
</span> * @method display
 *
 * Callback that actually renders the scene.
 * 
 * @template
 */
CGFscene.prototype.display = function () {
    this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
};

<span id='CGFscene-method-setGlobalAmbientLight'>/**
</span> * @method setGlobalAmbientLight
 *
 * Sets the global ambient light, that will illuminate every geometry with an ambient component, 
 * even if there are no more lights enabled. In the default CGFscene, it is set to (0.1,0.1,0.1, 1.0)
 * 
 * @param {Number} r the red component
 * @param {Number} g the green component
 * @param {Number} b the blue component
 * @param {Number} a the alpha component
 * 
 */
 CGFscene.prototype.setGlobalAmbientLight = function (r, g, b, a) {
	this.shader.bind();
	
	this.gl.uniform4f(this.shader.uniforms.uGlobalAmbient, r, g, b, a);
	
	this.shader.unbind();

};


</pre>
</body>
</html>
